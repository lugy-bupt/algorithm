# 数组

排序
排列组合问题



## 背包问题


### 01背包问题
0-1背包问题是指每一种物品都只有一件，可以选择放或者不放。现在假设有n件物品，背包承重为m。

对于这种问题，我们可以采用一个二维数组去解决：f[i][j]，其中i代表加入背包的是前i件物品，j表示背包的承重，f[i][j]表示当前状态下能放进背包里面的物品的最大总价值。那么，f[n][m]就是我们的最终结果了。

采用动态规划，必须要知道初始状态和状态转移方程。初始状态很容易就能知道，那么状态转移方程如何求呢？对于一件物品，我们有放进或者不放进背包两种选择：

（1）假如我们放进背包

    f[i][j] = f[i - 1][j - weight[i]] + value[i]
    
这里的f[i - 1][j - weight[i]] + value[i]应该这么理解：在没放这件物品之前的状态值加上要放进去这件物品的价值。而对于f[i - 1][j - weight[i]]这部分，i - 1很容易理解，关键是 j - weight[i]这里，我们要明白：要把这件物品放进背包，就得在背包里面预留这一部分空间。

（2）假如我们不放进背包，这个很容易理解。

    f[i][j] = f[i - 1][j]

因此，我们的状态转移方程就是：

    f[i][j] = max(f[i][j] = f[i - 1][j] , f[i - 1][j - weight[i]] + value[i])  

当然，还有一种特殊的情况，就是背包放不下当前这一件物品，这种情况下

    f[i][j] = f[i - 1][j]。  
    
特别的是，0-1背包问题还有一种更加节省空间的方法，那就是采用一维数组去解决
    
链表

字符串


二叉树

后续遍历

图

欧拉路径
topo排序

### 回溯法
回溯法（backtracking）是暴力搜索法中的一种。

对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。

在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法（深度优先遍历）来实现，在反复重复上述的步骤后可能出现两种情况：

找到一个可能存在的正确的答案
在尝试了所有可能的分步方法后宣告该问题没有答案
在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

示例
https://leetcode-cn.com/problems/combinations/

        class Solution:
            def subsets(self, nums):
                if len(nums) == 0: return []

                ret = []
                stack = []

                def dfs(s: int):  
                    print(s)
                    if s == len(nums):
                        return

                    if len(stack) > 0:
                        ret.append([] + stack)

                    for i in range(s, len(nums)):
                        stack.append(nums[i])
                        dfs(i + 1)
                        stack.pop()

                dfs(0)
                return ret
