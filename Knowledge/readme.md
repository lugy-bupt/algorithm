# 数组

排序
排列组合问题
## 字符串计算

## 前序后序表达式
中序表达式对我们而言是很直观的（我们平时接触的就是这个），但计算机处理起来比较麻烦（括号、优先级之类的），如2*3/(2-1)+3*(4-1)。前序和后序表达式中没有括号，而且在计算中只需单向扫描，不需要考虑运算符的优先级。

前序表达式就是前缀表达式，不含括号的算术表达式，而且它是将运算符写在前面，操作数写在后面的表达式，也称为“波兰式”。后序表达式同理

前序表达式是一种十分有用的表达式，它将中序表达式转换为可以依靠简单的操作就能得到运算结果的表达式。例如，(a+b)*(c+d)转换为 *+ab+cd。转为后序表达式为 ab+cd+*

前序和后序表达式的优势在于只用两种简单的操作，入栈和出栈就可以解决任何中序表达式的运算。其运算方式为：如果当前字符(或字符串)为数字或变量，则压入栈内；如果是运算符，则将栈顶两个元素弹出栈外并作相应运算，再将结果压入栈内。当前序表达式扫描结束时，栈里的就是中序表达式运算的最终结果。


## 背包问题


### 01背包问题
0-1背包问题是指每一种物品都只有一件，可以选择放或者不放。现在假设有n件物品，背包承重为m。

对于这种问题，我们可以采用一个二维数组去解决：f[i][j]，其中i代表加入背包的是前i件物品，j表示背包的承重，f[i][j]表示当前状态下能放进背包里面的物品的最大总价值。那么，f[n][m]就是我们的最终结果了。

采用动态规划，必须要知道初始状态和状态转移方程。初始状态很容易就能知道，那么状态转移方程如何求呢？对于一件物品，我们有放进或者不放进背包两种选择：

（1）假如我们放进背包

    f[i][j] = f[i - 1][j - weight[i]] + value[i]
    
这里的f[i - 1][j - weight[i]] + value[i]应该这么理解：在没放这件物品之前的状态值加上要放进去这件物品的价值。而对于f[i - 1][j - weight[i]]这部分，i - 1很容易理解，关键是 j - weight[i]这里，我们要明白：要把这件物品放进背包，就得在背包里面预留这一部分空间。

（2）假如我们不放进背包，这个很容易理解。

    f[i][j] = f[i - 1][j]

因此，我们的状态转移方程就是：

    f[i][j] = max(f[i][j] = f[i - 1][j] , f[i - 1][j - weight[i]] + value[i])  

当然，还有一种特殊的情况，就是背包放不下当前这一件物品，这种情况下

    f[i][j] = f[i - 1][j]。  
    
特别的是，0-1背包问题还有一种更加节省空间的方法，那就是采用一维数组去解决
    
链表

字符串


二叉树

后续遍历

图

欧拉路径
topo排序

