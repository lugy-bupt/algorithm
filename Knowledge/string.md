# 字符串

## 字符串匹配

## 表达式计算

## 前序后序表达式
中序表达式对我们而言是很直观的（我们平时接触的就是这个），但计算机处理起来比较麻烦（括号、优先级之类的），如
    
    2*3/(2-1)+3*(4-1)

前序和后序表达式中没有括号，而且在计算中只需单向扫描，不需要考虑运算符的优先级。

前序表达式就是前缀表达式，不含括号的算术表达式，而且它是将运算符写在前面，操作数写在后面的表达式，也称为“波兰式”。后序表达式将操作数写在前面，运算符写在后面，称为“逆波兰式＂

前序/后序表达式是一种十分有用的表达式，它将中序表达式转换为可以依靠简单的操作就能得到运算结果的表达式。例如
    
    (a+b)*(c+d)
    
转换为 
    
    *+ab+cd
    
转为后序表达式为 

    ab+cd+*
    

### 前序表达式计算结果

前序/后序表达式的优势在于只用入栈和出栈就可以解决任何中序表达式的运算。其运算方式为：

  (1)如果当前字符(或字符串)为数字或变量，则压入栈内；
  
  (2)如果是运算符，则将栈顶两个元素弹出栈外并作相应运算，再将结果压入栈内。

当表达式扫描结束时，栈里的就是中序表达式运算的最终结果。
  
这个简单例子支持0-9数字的前序表达式计算

    class Solution:
        def calculate(self, s: str) -> int:
            if s == "" : return 0

            stack = []

            def cal(op, a, b) -> int:
                if op == "+":
                    return a + b
                elif op == "-":
                    return a - b
                elif op == "*":
                    return a * b
                else:
                    return a // b

            for i in range(len(s) - 1, -1, -1):
                if s[i].isdigit():
                    stack.append(int(s[i]))
                else:
                    b = stack.pop()
                    a = stack.pop()
                    stack.append(cal(s[i], a, b))
            return stack[-1]
            
            
    Input : "-2*34"
    Output: 10
         

### 中序转前序表达式算法
